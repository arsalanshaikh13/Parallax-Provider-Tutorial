# docker image to use for all jobs
image: alpine:latest

# set workflow rules for all the stages, exit the workflow if rules don't match
workflow:
  rules:
    # run pipeline on branch push, tag push and only through api source
    # and avoid double pipeline trigger one through api source and other through gitlab username source
    - if:
        '($CI_COMMIT_BRANCH == "gitlabci" || $CI_COMMIT_TAG) &&
        $CI_PIPELINE_SOURCE == "api"'
      # check for changes in the file extension to run the pipeline
      changes:
        - '**.js'
        - '**.json'
        - '**.*rc'

    - when: never # do not run pipeline on any other condition

stages:
  - check
  - trigger

# This job explicitly checks for file changes and fails if none found
check_for_relevant_files:
  stage: check
  before_script:
    - apk add --no-cache git # since we are using git command in the script so install git here
    - chmod +x .gitlab/generate-pipeline.sh

  script:
    - sh .gitlab/generate-pipeline.sh
  # using artifacts:reports:dotenv to pass environment variable to the subsequent job as signal to start or stop subsequent jobs
  artifacts:
    paths:
      - .gitlab/pipeline-config.yml
    expire_in: 10 minutes
# https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-dynamic-child-pipeline
trigger_child_pipeline:
  stage: trigger
  trigger:
    include:
      - artifact: .gitlab/pipeline-config.yml
        job: check_for_relevant_files
    strategy: depend
